import { Component, computed, input, model, signal } from '@angular/core';
import { ThesaurusEntry } from '@myrmidon/cadmus-core';
import { DialogService } from '@myrmidon/ngx-mat-tools';

import { MatIcon } from '@angular/material/icon';
import { MatButton, MatIconButton } from '@angular/material/button';
import {
  MatExpansionPanel,
  MatExpansionPanelHeader,
  MatExpansionPanelTitle,
} from '@angular/material/expansion';
import { MatTooltip } from '@angular/material/tooltip';

import { EditOperation, OperationType } from '../services/edit-operation';
import { EditOperationComponent } from '../edit-operation/edit-operation.component';

/**
 * A set of edit operations to be applied to a base text.
 */
@Component({
  selector: 'cadmus-edit-operation-set',
  imports: [
    MatButton,
    MatExpansionPanel,
    MatExpansionPanelHeader,
    MatExpansionPanelTitle,
    MatIcon,
    MatIconButton,
    MatTooltip,
    EditOperationComponent,
  ],
  templateUrl: './edit-operation-set.component.html',
  styleUrl: './edit-operation-set.component.css',
})
export class EditOperationSetComponent {
  /**
   * The base text to which the operations are applied.
   */
  public readonly baseText = input.required<string>();
  /**
   * The optional target text (e.g. the standard form when the base
   * text is a misspelled form). This is used for diffing.
   */
  public readonly targetText = input<string | undefined>(undefined);
  /**
   * The operations to edit.
   */
  public readonly operations = model<EditOperation[]>([]);
  /**
   * Thesaurus orthography-tags.
   */
  public readonly tagEntries = input<ThesaurusEntry[] | undefined>(undefined);
  /**
   * Thesaurus orthography-op-tags.
   */
  public readonly opTagEntries = input<ThesaurusEntry[] | undefined>(undefined);
  /**
   * The currently edited operation (if any).
   */
  public readonly editedOperation = signal<EditOperation | undefined>(
    undefined
  );
  /**
   * The index of the currently edited operation (-1 if adding a new one).
   */
  public readonly editedOperationIndex = signal<number>(-1);

  /**
   * The input text for the operation being edited, i.e. the text
   * resulting from applying all preceding operations to the base text.
   */
  public readonly operationText = computed<string>(() => {
    // if we're adding the first operation or editing the first one,
    // its input is equal to the base text
    if (
      this.editedOperationIndex() === 0 ||
      (this.editedOperationIndex() === -1 && !this.operations().length)
    ) {
      return this.baseText() || '';
    }
    // else, the input must be calculated by executing one operation
    // after the another, starting from the fragment text with the first
    // operation, and up to the operation being edited (excluded)
    let text = this.baseText() || '';
    for (let i = 0; i < this.operations().length; i++) {
      if (i === this.editedOperationIndex()) {
        break;
      }
      text = this.operations()[i].execute(text);
    }
    return text;
  });

  /**
   * The final output text, i.e. the output text generated by executing
   * each operation from the list of operations, in sequence, starting
   * from the input text and ending with the last operation.
   */
  public readonly outputText = computed<string>(() => {
    try {
      let text = this.baseText() || '';
      for (let i = 0; i < this.operations().length; i++) {
        text = this.operations()[i].execute(text);
      }
      return text;
    } catch (error) {
      console.error('Error calculating output text', error);
      return '';
    }
  });

  constructor(private _dialogService: DialogService) {}

  public addOperation(): void {
    const operation: EditOperation = EditOperation.createOperation(
      OperationType.Replace
    );
    this.editedOperationIndex.set(-1);
    this.editedOperation.set(operation);
  }

  public editOperation(operation: EditOperation, index: number): void {
    this.editedOperationIndex.set(index);
    this.editedOperation.set(structuredClone(operation));
  }

  public closeOperation(): void {
    this.editedOperationIndex.set(-1);
    this.editedOperation.set(undefined);
  }

  public saveOperation(operation: EditOperation): void {
    const operations = [...this.operations()];
    if (this.editedOperationIndex() === -1) {
      operations.push(operation);
    } else {
      operations.splice(this.editedOperationIndex(), 1, operation);
    }
    this.operations.set(operations);
    this.closeOperation();
  }

  public deleteOperation(index: number): void {
    this._dialogService
      .confirm('Confirmation', 'Delete Operation?')
      .subscribe((yes: boolean | undefined) => {
        if (yes) {
          if (this.editedOperationIndex() === index) {
            this.closeOperation();
          }
          const operations = [...this.operations()];
          operations.splice(index, 1);
          this.operations.set(operations);
        }
      });
  }

  public moveOperationUp(index: number): void {
    if (index < 1) {
      return;
    }
    const entry = this.operations()[index];
    const entries = [...this.operations()];
    entries.splice(index, 1);
    entries.splice(index - 1, 0, entry);
    this.operations.set(entries);
  }

  public moveOperationDown(index: number): void {
    if (index + 1 >= this.operations().length) {
      return;
    }
    const entry = this.operations()[index];
    const entries = [...this.operations()];
    entries.splice(index, 1);
    entries.splice(index + 1, 0, entry);
    this.operations.set(entries);
  }

  public addByDiffing(): void {
    const a = this.baseText();
    const b = this.targetText();
    if (!a || !b || a === b) {
      return;
    }
    const operations = EditOperation.diff(a, b);
    if (operations.length) {
      this._dialogService
        .confirm('Confirmation', 'Reset operations via diffing?')
        .subscribe((yes: boolean | undefined) => {
          if (yes) {
            this.closeOperation();
            this.operations.set(operations);
          }
        });
    }
  }
}
