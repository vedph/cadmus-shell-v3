import { Component, computed, input, model, signal } from '@angular/core';

import { MatIcon } from '@angular/material/icon';
import { MatButton, MatIconButton } from '@angular/material/button';
import {
  MatExpansionPanel,
  MatExpansionPanelHeader,
  MatExpansionPanelTitle,
} from '@angular/material/expansion';
import { MatTooltip } from '@angular/material/tooltip';

import { ThesaurusEntry } from '@myrmidon/cadmus-core';
import { DialogService } from '@myrmidon/ngx-mat-tools';
import { FlatLookupPipe } from '@myrmidon/ngx-tools';
import { MatChip } from '@angular/material/chips';

import { EditOperation, OperationType } from '../services/edit-operation';
import { EditOperationComponent } from '../edit-operation/edit-operation.component';

/**
 * A set of edit operations to be applied to a base text. This shows the list
 * of operations, allows adding, editing, deleting, and reordering them,
 * and shows the resulting output text. It also allows adding operations
 * by diffing the base text with a target text.
 */
@Component({
  selector: 'cadmus-edit-operation-set',
  imports: [
    MatButton,
    MatChip,
    MatExpansionPanel,
    MatExpansionPanelHeader,
    MatExpansionPanelTitle,
    MatIcon,
    MatIconButton,
    MatTooltip,
    EditOperationComponent,
    FlatLookupPipe,
  ],
  templateUrl: './edit-operation-set.component.html',
  styleUrl: './edit-operation-set.component.css',
})
export class EditOperationSetComponent {
  /**
   * The base text to which the operations are applied.
   */
  public readonly baseText = input.required<string>();
  /**
   * The optional target text (e.g. the standard form when the base
   * text is a misspelled form). This is used for diffing.
   */
  public readonly targetText = input<string | undefined>(undefined);
  /**
   * The operations to edit.
   */
  public readonly operations = model<EditOperation[]>([]);
  /**
   * Thesaurus orthography-tags.
   */
  public readonly tagEntries = input<ThesaurusEntry[] | undefined>(undefined);
  /**
   * Thesaurus orthography-op-tags.
   */
  public readonly opTagEntries = input<ThesaurusEntry[] | undefined>(undefined);
  /**
   * The currently edited operation (if any).
   */
  public readonly editedOperation = signal<EditOperation | undefined>(
    undefined
  );
  /**
   * The index of the currently edited operation (-1 if adding a new one).
   */
  public readonly editedOperationIndex = signal<number>(-1);

  /**
   * The input text for the operation being edited, i.e. the text
   * resulting from applying all preceding operations to the base text.
   */
  public readonly operationText = computed<string>(() => {
    // if we're adding the first operation or editing the first one,
    // its input is equal to the base text
    if (
      this.editedOperationIndex() === 0 ||
      (this.editedOperationIndex() === -1 && !this.operations().length)
    ) {
      return this.baseText() || '';
    }
    // else, the input must be calculated by executing one operation
    // after the another, starting from the fragment text with the first
    // operation, and up to the operation being edited (excluded)
    let text = this.baseText() || '';
    for (let i = 0; i < this.operations().length; i++) {
      if (i === this.editedOperationIndex()) {
        break;
      }
      text = this.operations()[i].execute(text);
    }
    return text;
  });

  /**
   * The final output text, i.e. the output text generated by executing
   * each operation from the list of operations, in sequence, starting
   * from the input text and ending with the last operation.
   */
  public readonly outputText = computed<string>(() => {
    const texts = this.operationTexts();
    if (texts.length === 0) {
      return this.baseText() || '';
    }
    return texts[texts.length - 1].output;
  });

  /**
   * The input and output text for each operation in the list.
   * Each item contains the input text before the operation and the
   * output text after the operation.
   */
  public readonly operationTexts = computed<
    Array<{ input: string; output: string }>
  >(() => {
    const results: Array<{ input: string; output: string }> = [];
    let text = this.baseText() || '';

    for (let i = 0; i < this.operations().length; i++) {
      const input = text;
      try {
        text = this.operations()[i].execute(text);
        results.push({ input, output: text });
      } catch (error) {
        console.error(`Error executing operation ${i}`, error);
        results.push({ input, output: '(error)' });
      }
    }

    return results;
  });

  constructor(private _dialogService: DialogService) {}

  /**
   * TrackBy function for the operations list to avoid performance warnings.
   * Uses the operation's string representation as a unique identifier.
   */
  public trackByOperation(index: number, operation: EditOperation): string {
    return `${index}-${operation.toString()}`;
  }

  public addOperation(): void {
    const operation: EditOperation = EditOperation.createOperation(
      OperationType.Replace
    );
    this.editedOperationIndex.set(-1);
    this.editedOperation.set(operation);
  }

  public editOperation(operation: EditOperation, index: number): void {
    this.editedOperationIndex.set(index);
    this.editedOperation.set(structuredClone(operation));
  }

  public closeOperation(): void {
    this.editedOperationIndex.set(-1);
    this.editedOperation.set(undefined);
  }

  public saveOperation(operation: EditOperation): void {
    const operations = [...this.operations()];
    if (this.editedOperationIndex() === -1) {
      operations.push(operation);
    } else {
      operations.splice(this.editedOperationIndex(), 1, operation);
    }
    this.operations.set(operations);
    this.closeOperation();
  }

  public deleteOperation(index: number): void {
    this._dialogService
      .confirm('Confirmation', 'Delete Operation?')
      .subscribe((yes: boolean | undefined) => {
        if (yes) {
          if (this.editedOperationIndex() === index) {
            this.closeOperation();
          }
          const operations = [...this.operations()];
          operations.splice(index, 1);
          this.operations.set(operations);
        }
      });
  }

  public moveOperationUp(index: number): void {
    if (index < 1) {
      return;
    }
    const entry = this.operations()[index];
    const entries = [...this.operations()];
    entries.splice(index, 1);
    entries.splice(index - 1, 0, entry);
    this.operations.set(entries);

    // update edited index if the moved operation is being edited
    if (this.editedOperationIndex() === index) {
      this.editedOperationIndex.set(index - 1);
    } else if (this.editedOperationIndex() === index - 1) {
      // if the operation above was being edited, it moves down
      this.editedOperationIndex.set(index);
    }
  }

  public moveOperationDown(index: number): void {
    if (index + 1 >= this.operations().length) {
      return;
    }
    const entry = this.operations()[index];
    const entries = [...this.operations()];
    entries.splice(index, 1);
    entries.splice(index + 1, 0, entry);
    this.operations.set(entries);

    // update edited index if the moved operation is being edited
    if (this.editedOperationIndex() === index) {
      this.editedOperationIndex.set(index + 1);
    } else if (this.editedOperationIndex() === index + 1) {
      // if the operation below was being edited, it moves up
      this.editedOperationIndex.set(index);
    }
  }

  public addByDiffing(): void {
    const a = this.baseText();
    const b = this.targetText();
    if (!a || !b || a === b) {
      return;
    }
    const operations = EditOperation.diff(a, b);
    if (operations.length) {
      this._dialogService
        .confirm('Confirmation', 'Reset operations via diffing?')
        .subscribe((yes: boolean | undefined) => {
          if (yes) {
            this.closeOperation();
            this.operations.set(operations);
          }
        });
    }
  }
}
